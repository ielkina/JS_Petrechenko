'use strict';
//Циклы
//Для повторений однотипных действий используют прием -циклы.

//Первый синтаксис
let num = 50;
while (num < 55) {
	console.log(num);//50 51 52 53 54 
	num++;
}

//Второй синтаксис
let num = 50;
do {          //do - с английского сделай что-то 
	console.log(num); //50 51 52 53 54
	num++;
}
while (num < 55);

// третий синтаксис For
let num = 50;
for (let i = 1; i < 8; i++) {  //i сокращенно от index
	console.log(i); //1 2 3 4 5 6 7
}

for (let i = 1; i < 8; i++) {
	if (i === 6) {
		// break; // оператор break прерывает на 6
		continue;
		//оператор continue пропускает 6 и продолжает выполнять операцию
	}
	console.log(i); //1 2 3 4 5 7
}


/* ЗАДАЧИ 
1. Какое последнее значение выведет этот код? Почему?*/
let i = 3;

while (i) {
	alert(i--);
}
/*РЕШЕНИЕ
Ответ: 1.
let i = 3;
while (i) {
  alert( i-- );
}
Каждое выполнение цикла уменьшает i. Проверка while(i) остановит цикл при i = 0.
Соответственно, будет такая последовательность шагов цикла («развернём» цикл):
let i = 3;
alert(i--); // выведет 3, затем уменьшит i до 2
alert(i--) // выведет 2, затем уменьшит i до 1
alert(i--) // выведет 1, затем уменьшит i до 0
// все, проверка while(i) не даст выполняться циклу дальше 

2. Какие значения выведет цикл while?
Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.
Оба цикла выводят alert с одинаковыми значениями или нет?
Префиксный вариант ++i:
let i = 0;
while (++i < 5) alert( i );
Постфиксный вариант i++
let i = 0;
while (i++ < 5) alert( i );
РЕШЕНИЕ
Задача демонстрирует, как постфиксные/префиксные варианты могут 
повлиять на результат, когда используются в сравнениях.
1) От 1 до 4 */
let i = 0;
while (++i < 5) alert(i);
/* Первое значение: i = 1, так как операция ++i сначала увеличит i,
 а потом уже произойдёт сравнение и выполнение alert.
Далее 2, 3, 4… Значения выводятся одно за другим. Для
 каждого значения сначала происходит увеличение, а потом –
  сравнение, так как ++ стоит перед переменной.
При i = 4 произойдёт увеличение i до 5, а потом сравнение 
while (5 < 5) – это неверно. Поэтому на этом цикл остановится,
 и значение 5 выведено не будет.
 2) От 1 до 5 */
let i = 0;
while (i++ < 5) alert(i);
/* Первое значение: i = 1. Остановимся на нём подробнее. Оператор 
i++ увеличивает i, возвращая старое значение, так что в сравнении 
i++ < 5 будет участвовать старое i = 0.
Но последующий вызов alert уже не относится к этому выражению, так
 что получит новый i = 1.
Далее 2, 3, 4… Для каждого значения сначала происходит сравнение, 
а потом – увеличение, и затем срабатывание alert.
Окончание цикла: при i = 4 произойдёт сравнение while (4 < 5) –
 верно, после этого сработает i++, увеличив i до 5, так что значение
  5 будет выведено. Оно станет последним.
Значение i = 5 последнее, потому что на следующем шаге while (5 < 5) ложно.

3. Какие значения выведет цикл for?
Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.
Оба цикла выведут alert с одинаковыми значениями или нет?
1
Постфиксная форма:*/
for (let i = 0; i < 5; i++) alert(i);
/*
2
Префиксная форма: */
for (let i = 0; i < 5; ++i) alert(i);
/*
РЕШЕНИЕ
Ответ: от 0 до 4 в обоих случаях.
for (let i = 0; i < 5; ++i) alert( i );
for (let i = 0; i < 5; i++) alert( i );
Такой результат обусловлен алгоритмом работы for:
Выполнить единожды присваивание i = 0 перед чем-либо (начало).
Проверить условие i < 5
Если true – выполнить тело цикла alert(i), и затем i++
Увеличение i++ выполняется отдельно от проверки условия (2),
 значение i при этом не используется, поэтому нет никакой разницы 
 между i++ и ++i. 

4. Выведите чётные числа
При помощи цикла for выведите чётные числа от 2 до 10.
РЕШЕНИЕ */
for (let i = 2; i <= 10; i++) {
	if (i % 2 == 0) {
		alert(i);
	}
}
/*Для проверки на чётность мы здесь используем оператор получения остатка от 
деления %.

5. Замените for на while
Перепишите код, заменив цикл for на while, без изменения поведения цикла.*/
for (let i = 0; i < 3; i++) {
	alert(`number ${i}!`);
}
/*
РЕШЕНИЕ*/
let i = 0;
while (i < 3) {
	alert(`number ${i}!`);
	i++;
}
/*

6. Повторять цикл, пока ввод неверен
Напишите цикл, который предлагает prompt ввести число, большее 100. Если посетитель
ввёл другое число – попросить ввести ещё раз, и так далее.
Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100, либо
не нажмёт кнопку Отмена (ESC).
Предполагается, что посетитель вводит только числа. Предусматривать обработку 
нечисловых строк в этой задаче необязательно.
РЕШЕНИЕ */
let num;

do {
	num = prompt("Введите число больше 100?", 0);
} while (num <= 100 && num);
/*
Цикл do..while повторяется, пока верны две проверки:
Проверка num <= 100 – то есть, введённое число всё ещё меньше 100.
Проверка && num вычисляется в false, когда num имеет значение null или пустая строка
 ''. В этом случае цикл while тоже нужно прекратить.
Кстати, сравнение num <= 100 при вводе null даст true, так что вторая проверка 
необходима.

7. Вывести простые числа
Натуральное число, большее 1, называется простым, если оно ни на что не делится,
 кроме себя и 1.
Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и 
n есть остаток.
Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 
и 4.
Напишите код, который выводит все простые числа из интервала от 2 до n.
Для n = 10 результат должен быть 2,3,5,7.
P.S. Код также должен легко модифицироваться для любых других интервалов.
РЕШЕНИЕ
Существует множество алгоритмов решения этой задачи.
Давайте воспользуемся вложенными циклами:
Для всех i от 1 до 10 {
  проверить, делится ли число i на какое-либо из чисел до него
  если делится, то это i не подходит, берём следующее
  если не делится, то i - простое число
}
Решение с использованием метки:
let n = 10;

nextPrime:
for (let i = 2; i <= n; i++) { // Для всех i...

  for (let j = 2; j < i; j++) { // проверить, делится ли число..
	 if (i % j == 0) continue nextPrime; // не подходит, берём следующее
  }

  alert( i ); // простое число
}
Конечно же, его можно оптимизировать с точки зрения производительности.
 Например, проверять все j не от 2 до i, а от 2 до квадратного корня из i. 
 А для очень больших чисел – существуют более эффективные специализированные
  алгоритмы проверки простоты числа, например квадратичное решето и решето 
  числового поля. */